
package calculator;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Stack;
import java.util.StringTokenizer;

public class Main {

	private String[] tokenize(String exp) {
		String[] r = null;
		if (exp != null) {
			StringBuffer sb = new StringBuffer();
			char[] chs = exp.toCharArray();
			for (Character c : chs)
				if (c == '(' || c == ')' || c == ',') {
					sb.append(' ');
					sb.append(c);
					sb.append(' ');					
				} else sb.append(c);
			StringTokenizer st = new StringTokenizer(sb.toString());
			r = new String[st.countTokens()];
			int c = 0;
			while (st.hasMoreTokens())
				r[c++] = st.nextToken().toLowerCase();
		}
		return r;
	}
	
	public Long calc(String exp) {
		tokens = tokenize(exp);
		counter = -1;
		return processState0();
	}

	private static int state = 0;

	private static HashMap<String, Long> ids = new HashMap<String, Long>();
	
	private static String LET = "let";
	private static String ADD = "add";
	private static String SUB = "sub";
	private static String MULT = "mult";
	private static String DIV = "div";
	private static String LEFT = "(";
	private static String RIGHT = ")";
	private static String COMMA = ",";

	private Stack<String> op = new Stack<String>();
	
	private static int counter = -1;
	private static String[] tokens;

	private static void log(int state, String msg) {
		System.out.println("[INFO] state " + state + msg);
	}
	
	private static String nextToken() {
		return tokens[++counter];
	}

	private static String currentToken() {
		return tokens[counter];
	}
	
	private boolean isLet(String token) {
		return LET.equals(token);
	}

	private boolean isAdd(String token) {
		return ADD.equals(token);
	}

	private boolean isSub(String token) {
		return SUB.equals(token);
	}

	private boolean isMult(String token) {
		return MULT.equals(token);
	}

	private boolean isDiv(String token) {
		return DIV.equals(token);
	}

	private boolean isOperator(String token) {
		return isAdd(token) || isSub(token) || isMult(token) || isDiv(token);
	}

	private boolean isLeft(String token) {
		return LEFT.equals(token);
	}

	private boolean isRight(String token) {
		return RIGHT.equals(token);
	}

	private boolean isComma(String token) {
		return COMMA.equals(token);
	}

	private boolean isInt(String token)  {  
		try  {
			Long.parseLong(token);
		} catch (NumberFormatException e) {
			return false;
		}
		return true;
	}

	private Long toInt(String token) {
		return Long.parseLong(token);
	}

	private boolean isId(String token) {
		return token != null && token.matches("[a-zA-Z]+") && !isOperator(token) && !isLet(token);
	}
	
	private void throwSyntaxError(String unexpectedToken, String expectedToken) {
		throw new RuntimeException("unexpected token " + unexpectedToken + "; expected: " + expectedToken);
	}

	
	private void throwUndefinedIdError(String id) {
		throw new RuntimeException("undefined id: " + id + ".");
	}

	private Long processState0() {
		String token = nextToken();
		log(0, token);
		if (isOperator(token)) return processState1(token);
		else if (isLet(token)) return processState6();
		else throwSyntaxError(token, "let or operator.");
		return null;
	}

	private Long processState1(String operator) {
		
		if (isLeft(nextToken())) {
			log(1, currentToken());
			Long r = processState2(operator);
			log (1, "rval from state 2: " + r);
			if (isRight(nextToken())) return r;
			else throwSyntaxError(currentToken(), ").");
		}
		else throwSyntaxError(currentToken(), "(");
		return null;
	}

	private Long processState2(String operator) {
		String token = nextToken();
		log(2, "token: " + operator);
		if (isInt(token)) {
			Long r = processState3(operator, token);
			log(22, r.toString());
			return r;
		}
		else if (isId(token)) {
			Long r = processState3d1(operator, token);
			log(2, r.toString());
			return r;
		} else if (isLet(token) || isOperator(token)) return processState1(token);
		else throwSyntaxError(token, "a legal expression.");
		return null;
	}

	private Long processState3(String operator, String operand) {
		if (isComma(nextToken())) {
			Long r = processState4(operator, operand);
			log(3, r.toString());
			return r;
		}
		else throwSyntaxError(currentToken(), ",.");
		return null;
	}

	private Long processState3d1(String operator, String idForOperandLeft) {
		Long operandLeft = ids.get(idForOperandLeft);
		log(31, operandLeft.toString());
		if (operandLeft != null) return processState3(operator, operandLeft.toString());
		else throwUndefinedIdError(idForOperandLeft);
		return null;
	}

	private Long processState4(String operator, String operand) {
		String token = nextToken();
		if (isInt(token)) return processState5(operator, operand, token);
		else if (isId(token)) {
			 Long r = processState5d1(operator, operand, token);
			 log(4, r.toString());
			 return r;
		} else if (isLet(token) || isOperator(token)) {
			counter--;
			Long r = processState0();
			log(42, r.toString());
			return processState5(operator, operand, r.toString());
		}
		else throwSyntaxError(token, "a legal expression.");
		return null;
	}

	private Long processState5(String operator, String operandLeft, String operandRight) {
		//		if (isRight(nextToken())) {
			long left = toInt(operandLeft);
			long right = toInt(operandRight);
			if (isAdd(operator)) return new Long(left + right);
			else if (isSub(operator)) return new Long(left - right);
			else if (isMult(operator)) return new Long(left * right);
			else if (isDiv(operator)) return new Long(left / right);
			//		} else throwSyntaxError(currentToken(), ").");
		return null;
	}
	
	private Long processState5d1(String operator, String operandLeft, String idForOperandRight) {
		Long operandRight = ids.get(idForOperandRight);
		log(51, operandRight.toString());
		if (operandRight != null) {
			Long r = processState5(operator, operandLeft, operandRight.toString());
			log(51, r.toString());
			return r;
		}
		throwUndefinedIdError(idForOperandRight);
		return null;
	}
	
	private Long processState6() {
		if (isLeft(nextToken())) {
			Long r = processState7();
			if (isRight(nextToken())) return r;
			else throwSyntaxError(currentToken(), ").");
		}
		else throwSyntaxError(currentToken(), "(.");
		return null;
	}

	private Long processState7() {
		if (isId(nextToken())) return processState8(currentToken());
		else throwSyntaxError(currentToken(), "an id.");
		return null;
	}

	private Long processState8(String id) {
		if (isComma(nextToken())) return processState9(id);
		else throwSyntaxError(currentToken(), ",.");
		return null;
	}

	private Long processState9(String id) {
		String token = nextToken();
		Long operandLeft = null;
		if (isInt(token)) operandLeft = toInt(token);
		else operandLeft = processState0();
		System.out.println(".." + operandLeft);
		ids.put(id, operandLeft);
		return processState10();
	}

	private Long processState10() {
		if (isComma(nextToken())) return processState11();
		else throwSyntaxError(currentToken(), ",.");
		return null;
	}

	private Long processState11() {
		String token = nextToken();
		System.out.println(currentToken() + ">>" + token + ":" + isId(token));
		if (isInt(token)) return toInt(currentToken());
		else if (isId(currentToken())) {
			Long val = ids.get(currentToken());
			if (val != null) return val;
			else throwUndefinedIdError(currentToken());
		} else {
			counter--;
			return processState0();
		}
		return null;
	}
	
	public static void main(String... args) {
		Main m = new Main();
		String exp = "let (abc, 0, add(abc, 2))";
		String[] s = m.tokenize(exp);
		System.out.println("parsing " + exp + ":\n" + Arrays.deepToString(s));
		System.out.println("很好");
		System.out.println(m.calc("add(1, 2)"));
		System.out.println(m.calc("mult(2, 3)"));
		System.out.println(m.isId("a"));
		System.out.println(m.calc("let(a, 5, a)"));
		System.out.println(m.calc("let(a, 5, add(a, a))"));
		System.out.println(m.calc("add(1, mult(2, 3))"));
		System.out.println(m.calc("add(sub(2, 1), mult(2, 3))"));
	}
	
}
